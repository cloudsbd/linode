import{j as e,a0 as j,T as r,B as y,bt as L,iY as F,ba as $,iZ as B,bB as k,bN as W,f as N,cR as O,a4 as V,bC as M}from"./index-Eksrs3uK.js";import{u as D}from"./formik.esm-Kap5lsIh.js";import{A as G,S as Q}from"./Autocomplete-XvrzKoAo.js";import{B as Y}from"./vpcs-SI1JeFoo.js";import"./stackscripts-7LZsSbBg.js";import{b as U,T as E,a as b,c as z}from"./TableRow-phXfWUGW.js";import{T as Z}from"./TableRowEmpty-aXmC67-Z.js";import{T as J}from"./TableHead-Si_pzkLK.js";const le=[{description:"Service targets are selected one after another in a repeating order. If unequal weights are assigned, service targets with a greater weight appear more frequently in the round robin rotation.",label:"Round Robin",value:"round_robin"},{description:"The service target with the fewest number of active requests is selected. If unequal weights are assigned, weighted round robin rotation is applied.",label:"Least Request",value:"least_request"},{description:"Each service target is mapped into a circle (ring) by hashing its address. Each request is then routed clockwise around the ring to the nearest service target.",label:"Ring Hash",value:"ring_hash"},{description:"A random available service target is selected.",label:"Random",value:"random"},{description:"Reads the upstream hash to make content-aware routing decisions.",label:"Maglev",value:"maglev"}],ce=[{label:"TCP",value:"tcp"},{label:"HTTP",value:"http"},{label:"HTTPS",value:"https"}],he={certificate_id:null,endpoints:[],healthcheck:{healthy_threshold:3,host:"",interval:10,path:"",protocol:"http",timeout:5,unhealthy_threshold:3},label:"",load_balancing_policy:"round_robin",percentage:10,protocol:"https"},P={Description:"Configuration for a new service target and its endpoints that the load balancer directs incoming requests to.",Tooltips:{Algorithm:"Policy type that decides how the load balancer allocates new connections across your service targets.",Certificate:"Service target CA certificates are installed on your endpoints. Global Load Balancer uses these certificates to verify responses from your service targets to your clients.",Endpoints:{Capacity:"The maximum number of requests/second that can be directed to this endpoint. If the actual number of requests/second exceeds the configured capacity value, requests are distributed to the other endpoints.",Host:"Optional host header for HTTP/S requests to the endpoint. Not used to look up the IP address in the DNS.",IP:"The private IP address of the endpoint on a Compute Instance (Linode). For non-Linode endpoints, enter the public IPv4 or IPv6 address. Do not use 127.0.0.0/8 for the endpoint IP address.",Port:"The service target port that the load balancer directs incoming requests to. This is the port that the application is listening on."},Healthcheck:{Description:"When enabled, health checks query the service targets by performing TCP connections or by making HTTP/S requests. For TCP, a service target is considered healthy and able to accept incoming requests when there is a successful TCP handshake with the service target. When HTTP/S is used to validate health status, the service target is considered healthy when requests to its path or host return a 2xx or 3xx status code response.",Healthy:"The number of consecutive health checks that must be successful in order to consider a service target as healthy. Minimum value is 1.",Host:e.jsxs(j,{spacing:1,children:[e.jsx(r,{children:"When the Protocol is set to HTTP/S, enter the request host for the health check."}),e.jsx(r,{children:"Health Check Host is not applicable when the health check Protocol is set to TCP."})]}),Interval:"The number of seconds between health checks for this service target. Minimum value is 1.",Path:e.jsxs(j,{spacing:1,children:[e.jsx(r,{children:"When the Protocol is set to HTTP/S, enter the request url path for the health check."}),e.jsx(r,{children:"Health Check Path is not applicable when the health check Protocol is set to TCP."})]}),Protocol:e.jsxs(j,{spacing:2,children:[e.jsx(r,{children:"An HTTP/S health check verifies health status by sending requests to the endpoint Health Check Path or Health Check Host."}),e.jsx(r,{children:"A TCP health check verifies health status by connecting to the endpoints port. When set to TCP, Health Check Path and Health Check Host are not applicable."}),e.jsx(r,{children:"You can select TCP health checks even when the load balancer's entry point protocol is HTTP or HTTPS."})]}),Timeout:"How long to wait (in seconds) before canceling a health check because a connection could not be established with the service target. Minimum value is 1.",Unhealthy:"The number of consecutive health checks that must fail to consider a service target as unhealthy. Minimum value is 1."},Protocol:e.jsxs(y,{children:["The protocol this target is configured to serve.",e.jsxs("ul",{children:[e.jsx("li",{children:"The HTTP and TCP protocols do not support TLS certificates."}),e.jsx("li",{children:" HTTPS requires TLS certificates."})]})]})}},K=g=>{var I;const{errorText:h,onChange:t,textFieldProps:d,value:l}=g,[a,c]=L.useState(""),n={};a&&(n["+or"]=[{label:{"+contains":a}},{ipv4:{"+contains":a}}]);const{data:p,error:u,fetchNextPage:x,hasNextPage:f,isLoading:T}=F(n),{data:s}=$(),m=(p==null?void 0:p.pages.flatMap(i=>i.data))??[],C=l?(m==null?void 0:m.find(i=>i.ipv4.includes(l)))??null:null,_=i=>{const o=i.currentTarget;o.scrollTop+o.clientHeight>=o.scrollHeight&&f&&x()},H=Y.build({ipv4:[a],label:`Use IP ${a}`}),S=[...m];return m.length===0&&!T&&S.push(H),e.jsx(G,{ListboxProps:{onScroll:_},onInputChange:(i,o,v)=>{(v==="input"||v==="clear")&&(c(o),t(o))},renderOption:(i,o,v)=>{var q;const R=((q=s==null?void 0:s.find(A=>A.id===o.region))==null?void 0:q.label)??o.region,w=o===H;return e.jsxs("li",{...i,children:[e.jsxs(j,{flexGrow:1,children:[e.jsx(y,{children:e.jsx("b",{children:w?"Custom IP":o.label})}),e.jsx(y,{children:w?o.ipv4[0]:`${o.ipv4[0]} - ${R}`})]}),e.jsx(Q,{visible:v.selected})]})},errorText:((I=u==null?void 0:u[0])==null?void 0:I.reason)??h,filterOptions:i=>i,fullWidth:!0,inputValue:C?C.label:a,label:"Linode or Public IP Address",loading:T,onChange:(i,o)=>t((o==null?void 0:o.ipv4[0])??""),options:S,placeholder:"Select Linode or Enter IPv4 Address",textFieldProps:d,value:m.length===0?H:C})},X={host:"",ip:"",port:80,rate_capacity:1e4},de=g=>{const{onAdd:h}=g,t=D({initialValues:X,onSubmit(d,l){h(d),l.resetForm()},validationSchema:B});return e.jsxs(e.Fragment,{children:[e.jsxs(y,{children:[e.jsx(K,{textFieldProps:{labelTooltipText:P.Tooltips.Endpoints.IP},errorText:t.errors.ip,onChange:d=>t.setFieldValue("ip",d),value:t.values.ip}),e.jsx(k,{errorText:t.errors.port,label:"Port",labelTooltipText:P.Tooltips.Endpoints.Port,name:"port",onChange:t.handleChange,sx:{maxWidth:"100px"},type:"number",value:t.values.port}),e.jsx(k,{errorText:t.errors.host,label:"Host",labelTooltipText:P.Tooltips.Endpoints.Host,name:"host",onChange:t.handleChange,optional:!0,value:t.values.host}),e.jsx(k,{InputProps:{endAdornment:e.jsx(W,{position:"start",children:"Requests per second"})},errorText:t.errors.rate_capacity,label:"Rate Capacity",labelTooltipText:P.Tooltips.Endpoints.Capacity,name:"rate_capacity",onChange:t.handleChange,sx:{maxWidth:"275px"},type:"number",value:t.values.rate_capacity})]}),e.jsx(N,{buttonType:"outlined",onClick:()=>t.handleSubmit(),sx:{marginTop:2},children:"Add Endpoint"})]})},pe=g=>{const{endpoints:h,errors:t,onRemove:d}=g,{data:l}=O({page_size:500},{"+or":h.map(a=>({ipv4:{"+contains":a.ip}}))});return e.jsxs(U,{children:[e.jsx(J,{children:e.jsxs(E,{children:[e.jsx(b,{children:"Endpoint"}),e.jsx(b,{children:"Host"}),e.jsx(b,{})]})}),e.jsxs(z,{children:[h.length===0&&e.jsx(Z,{colSpan:3,message:"No endpoints to display."}),h.map((a,c)=>{var u,x,f,T;const n={host:(u=t==null?void 0:t.find(s=>s.field===`endpoints[${c}].host`))==null?void 0:u.reason,ip:(x=t==null?void 0:t.find(s=>s.field===`endpoints[${c}].ip`))==null?void 0:x.reason,port:(f=t==null?void 0:t.find(s=>s.field===`endpoints[${c}].port`))==null?void 0:f.reason,rate_capacity:(T=t==null?void 0:t.find(s=>s.field===`endpoints[${c}].rate_capacity`))==null?void 0:T.reason},p=l==null?void 0:l.data.find(s=>s.ipv4.includes(a.ip));return e.jsxs(E,{children:[e.jsxs(b,{children:[(p==null?void 0:p.label)??a.ip,":",a.port,n.ip&&e.jsx(r,{color:s=>s.palette.error.main,children:n.ip}),n.port&&e.jsx(r,{color:s=>s.palette.error.main,children:n.port}),n.rate_capacity&&e.jsx(r,{color:s=>s.palette.error.main,children:n.rate_capacity})]}),e.jsxs(b,{children:[a.host,n.host&&e.jsx(r,{color:s=>s.palette.error.main,children:n.host})]}),e.jsx(b,{actionCell:!0,children:e.jsx(V,{"aria-label":`Remove Endpoint ${a.ip}:${a.port}`,onClick:()=>d(c),children:e.jsx(M,{})})})]},c)})]})]})};export{de as A,pe as E,P as S,le as a,he as i,ce as p};
